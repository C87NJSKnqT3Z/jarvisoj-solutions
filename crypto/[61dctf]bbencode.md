## 描述

```python
flag = open("flag", "r").read().strip()
assert len(flag) == 32
def str2num(s):
    return int(s.encode('hex'), 16)
def bbencode(n):
    a = 0
    for i in bin(n)[2:]:
        a = a << 1
        if (int(i)):
            a = a ^ n
        if a >> 256:
            a = a ^ 0x10000000000000000000000000000000000000000000000000000000000000223L
    return a

print bbencode(str2num(flag))

#result:61406787709715709430385495960238216763226399960658358000016620560764164045692
```

## 题解

构造一些二进制数，找了下规律

```
110
10100

110111011110
10100010101000101010100

1001
1000001

100111
10000010101

100101
10000010001

1011101010010101110
1000101010001000100000100010001010100
```

发现了什么吗？？每一位后面都加了个 0！！！！然后再去掉最后面的那个 0！！也就是说，在长度不长的情况下，等价于

```python
s = ''
for i in bin(n)[2:]:
    s += i
    s += '0'
print(s[:-1])
```

但是有一个 `a = a ^ 0x10000000000000000000000000000000000000000000000000000000000000223L` 就比较烦，不过这个还是能处理的。

首先看一下这个大数是什么样的

```
>> a = 0x10000000000000000000000000000000000000000000000000000000000000223
>> b = bin(a)[2:]
>> len(b)
257
>> b
'10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000100011'
```

第 256 位是 1（最低位是第 0 位），而 `a >> 256` 这个条件为 True，就意味着 a 的第 256 位成为了 1，再亦或一次，就会将这位去掉。

这样就达到了一个目的：a 第 256 位之后（包含 256）的位永远不会是 1。

也就是说，加密出来的所有结果，是在模 2^(256) 意义下的一个环，也就是当加密次数到了一定的数目，加密的串会回到原来的起点，也就是相当于加密了 0 次，等于没加密。

但是这个环的长度会很大吗？根据亦或的性质可知，同一个数字，亦或两次就会变为 0，不过在这里并不是那么的显然，因为数字经过了移位，所以这个亦或的这个可逆性其实在这里并没有什么卵用。

不过这并不妨碍我们猜这个环的长度很短呀~万一呢？对吧。此时我们还要猜测，原来的明文应该包含什么样的串，比如 `flag`、`ctf` 这样的字眼，然后做一下验证。

```python
def bbencode(n):
    a = 0
    for i in bin(n)[2:]:
        a = a << 1
        if (int(i)):
            a = a ^ n
        if a >> 256:
            a = a ^ 0x10000000000000000000000000000000000000000000000000000000000000223
    return a

a = 61406787709715709430385495960238216763226399960658358000016620560764164045692
for _ in range(1000000):
    if _ % 10000 == 0:
        print(_)
    try:
        h = hex(a)[2:]
        s = bytes.fromhex(h)
        # if b'ctf' in s:
        if b'flag' in s:
            print(s)
    except:
        pass
    a = bbencode(a)
```

不到一会就出来了

## 答案

flag{you_xian_yu_huan_le_duo_!!}
